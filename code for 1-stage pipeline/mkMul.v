//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Mon Dec 11 01:23:20 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_val                    O     1
// get_val                        O   128 reg
// RDY_get_val                    O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_val_data                   I    64 reg
// put_val_q_                     I    64
// EN_put_val                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMul(CLK,
	     RST_N,

	     put_val_data,
	     put_val_q_,
	     EN_put_val,
	     RDY_put_val,

	     get_val,
	     RDY_get_val);
  input  CLK;
  input  RST_N;

  // action method put_val
  input  [63 : 0] put_val_data;
  input  [63 : 0] put_val_q_;
  input  EN_put_val;
  output RDY_put_val;

  // value method get_val
  output [127 : 0] get_val;
  output RDY_get_val;

  // signals for module outputs
  wire [127 : 0] get_val;
  wire RDY_get_val, RDY_put_val;

  // register accumulator
  reg [63 : 0] accumulator;
  reg [63 : 0] accumulator$D_IN;
  wire accumulator$EN;

  // register accumulator_1
  reg [63 : 0] accumulator_1;
  reg [63 : 0] accumulator_1$D_IN;
  wire accumulator_1$EN;

  // register accumulator_2
  reg [63 : 0] accumulator_2;
  reg [63 : 0] accumulator_2$D_IN;
  wire accumulator_2$EN;

  // register accumulator_3
  reg [63 : 0] accumulator_3;
  reg [63 : 0] accumulator_3$D_IN;
  wire accumulator_3$EN;

  // register accumulatorqq
  reg [128 : 0] accumulatorqq;
  reg [128 : 0] accumulatorqq$D_IN;
  wire accumulatorqq$EN;

  // register accumulatorqq_1
  reg [128 : 0] accumulatorqq_1;
  reg [128 : 0] accumulatorqq_1$D_IN;
  wire accumulatorqq_1$EN;

  // register accumulatorqq_2
  reg [128 : 0] accumulatorqq_2;
  reg [128 : 0] accumulatorqq_2$D_IN;
  wire accumulatorqq_2$EN;

  // register accumulatorqq_3
  reg [128 : 0] accumulatorqq_3;
  reg [128 : 0] accumulatorqq_3$D_IN;
  wire accumulatorqq_3$EN;

  // register counter
  reg [7 : 0] counter;
  wire [7 : 0] counter$D_IN;
  wire counter$EN;

  // register counter_1
  reg [7 : 0] counter_1;
  wire [7 : 0] counter_1$D_IN;
  wire counter_1$EN;

  // register counter_2
  reg [7 : 0] counter_2;
  wire [7 : 0] counter_2$D_IN;
  wire counter_2$EN;

  // register counter_3
  reg [7 : 0] counter_3;
  wire [7 : 0] counter_3$D_IN;
  wire counter_3$EN;

  // register delay
  reg [1 : 0] delay;
  wire [1 : 0] delay$D_IN;
  wire delay$EN;

  // register m
  reg [63 : 0] m;
  wire [63 : 0] m$D_IN;
  wire m$EN;

  // register m_1
  reg [63 : 0] m_1;
  wire [63 : 0] m_1$D_IN;
  wire m_1$EN;

  // register m_2
  reg [63 : 0] m_2;
  wire [63 : 0] m_2$D_IN;
  wire m_2$EN;

  // register m_3
  reg [63 : 0] m_3;
  wire [63 : 0] m_3$D_IN;
  wire m_3$EN;

  // register q
  reg [63 : 0] q;
  reg [63 : 0] q$D_IN;
  wire q$EN;

  // register q1
  reg q1;
  wire q1$D_IN, q1$EN;

  // register q1_1
  reg q1_1;
  wire q1_1$D_IN, q1_1$EN;

  // register q1_2
  reg q1_2;
  wire q1_2$D_IN, q1_2$EN;

  // register q1_3
  reg q1_3;
  wire q1_3$D_IN, q1_3$EN;

  // register q_1
  reg [63 : 0] q_1;
  reg [63 : 0] q_1$D_IN;
  wire q_1$EN;

  // register q_2
  reg [63 : 0] q_2;
  reg [63 : 0] q_2$D_IN;
  wire q_2$EN;

  // register q_3
  reg [63 : 0] q_3;
  reg [63 : 0] q_3$D_IN;
  wire q_3$EN;

  // register qq
  reg [1 : 0] qq;
  wire [1 : 0] qq$D_IN;
  wire qq$EN;

  // register qq_1
  reg [1 : 0] qq_1;
  wire [1 : 0] qq_1$D_IN;
  wire qq_1$EN;

  // register qq_2
  reg [1 : 0] qq_2;
  wire [1 : 0] qq_2$D_IN;
  wire qq_2$EN;

  // register qq_3
  reg [1 : 0] qq_3;
  wire [1 : 0] qq_3$D_IN;
  wire qq_3$EN;

  // register state
  reg [3 : 0] state;
  reg [3 : 0] state$D_IN;
  wire state$EN;

  // inputs to muxes for submodule ports
  wire [128 : 0] MUX_accumulatorqq$write_1__VAL_1,
		 MUX_accumulatorqq$write_1__VAL_2,
		 MUX_accumulatorqq$write_1__VAL_3,
		 MUX_accumulatorqq_1$write_1__VAL_1,
		 MUX_accumulatorqq_1$write_1__VAL_2,
		 MUX_accumulatorqq_1$write_1__VAL_3,
		 MUX_accumulatorqq_2$write_1__VAL_1,
		 MUX_accumulatorqq_2$write_1__VAL_2,
		 MUX_accumulatorqq_2$write_1__VAL_3,
		 MUX_accumulatorqq_3$write_1__VAL_1,
		 MUX_accumulatorqq_3$write_1__VAL_2,
		 MUX_accumulatorqq_3$write_1__VAL_3;
  wire [63 : 0] MUX_accumulator$write_1__VAL_2,
		MUX_accumulator$write_1__VAL_3,
		MUX_accumulator$write_1__VAL_4,
		MUX_accumulator_1$write_1__VAL_2,
		MUX_accumulator_1$write_1__VAL_3,
		MUX_accumulator_1$write_1__VAL_4,
		MUX_accumulator_2$write_1__VAL_2,
		MUX_accumulator_2$write_1__VAL_3,
		MUX_accumulator_2$write_1__VAL_4,
		MUX_accumulator_3$write_1__VAL_2,
		MUX_accumulator_3$write_1__VAL_3,
		MUX_accumulator_3$write_1__VAL_4,
		MUX_q$write_1__VAL_2,
		MUX_q$write_1__VAL_3,
		MUX_q_1$write_1__VAL_2,
		MUX_q_1$write_1__VAL_3,
		MUX_q_2$write_1__VAL_2,
		MUX_q_2$write_1__VAL_3,
		MUX_q_3$write_1__VAL_2,
		MUX_q_3$write_1__VAL_3;
  wire [7 : 0] MUX_counter$write_1__VAL_1;
  wire [3 : 0] MUX_state$write_1__VAL_1;
  wire MUX_accumulator$write_1__SEL_1,
       MUX_accumulator$write_1__SEL_2,
       MUX_accumulator_1$write_1__SEL_2,
       MUX_accumulator_2$write_1__SEL_2,
       MUX_accumulator_3$write_1__SEL_2;

  // remaining internal signals
  wire [63 : 0] x__h1298,
		x__h1360,
		x__h1429,
		x__h1476,
		x__h1547,
		x__h1594,
		x__h1665,
		x__h1712;

  // action method put_val
  assign RDY_put_val = state == 4'd0 ;

  // value method get_val
  assign get_val = accumulatorqq_3[128:1] ;
  assign RDY_get_val = counter == 8'd16 && state == 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_accumulator$write_1__SEL_1 = state == 4'd5 && counter == 8'd16 ;
  assign MUX_accumulator$write_1__SEL_2 =
	     state == 4'd6 && (qq == 2'b01 || qq == 2'b10) ;
  assign MUX_accumulator_1$write_1__SEL_2 =
	     state == 4'd6 && (qq_1 == 2'b01 || qq_1 == 2'b10) ;
  assign MUX_accumulator_2$write_1__SEL_2 =
	     state == 4'd6 && (qq_2 == 2'b01 || qq_2 == 2'b10) ;
  assign MUX_accumulator_3$write_1__SEL_2 =
	     state == 4'd6 && (qq_3 == 2'b01 || qq_3 == 2'b10) ;
  assign MUX_accumulator$write_1__VAL_2 =
	     (qq == 2'b01) ? x__h1298 : x__h1360 ;
  assign MUX_accumulator$write_1__VAL_3 = { 1'd0, accumulator[63:1] } ;
  assign MUX_accumulator$write_1__VAL_4 =
	     { accumulator[62], accumulator[62:0] } ;
  assign MUX_accumulator_1$write_1__VAL_2 =
	     (qq_1 == 2'b01) ? x__h1429 : x__h1476 ;
  assign MUX_accumulator_1$write_1__VAL_3 = { 1'd0, accumulator_1[63:1] } ;
  assign MUX_accumulator_1$write_1__VAL_4 =
	     { accumulator_1[62], accumulator_1[62:0] } ;
  assign MUX_accumulator_2$write_1__VAL_2 =
	     (qq_2 == 2'b01) ? x__h1547 : x__h1594 ;
  assign MUX_accumulator_2$write_1__VAL_3 = { 1'd0, accumulator_2[63:1] } ;
  assign MUX_accumulator_2$write_1__VAL_4 =
	     { accumulator_2[62], accumulator_2[62:0] } ;
  assign MUX_accumulator_3$write_1__VAL_2 =
	     (qq_3 == 2'b01) ? x__h1665 : x__h1712 ;
  assign MUX_accumulator_3$write_1__VAL_3 = { 1'd0, accumulator_3[63:1] } ;
  assign MUX_accumulator_3$write_1__VAL_4 =
	     { accumulator_3[62], accumulator_3[62:0] } ;
  assign MUX_accumulatorqq$write_1__VAL_1 = { 1'd0, accumulatorqq[128:1] } ;
  assign MUX_accumulatorqq$write_1__VAL_2 =
	     { accumulatorqq[127], accumulatorqq[127:0] } ;
  assign MUX_accumulatorqq$write_1__VAL_3 = { accumulator, q, q1 } ;
  assign MUX_accumulatorqq_1$write_1__VAL_1 =
	     { 1'd0, accumulatorqq_1[128:1] } ;
  assign MUX_accumulatorqq_1$write_1__VAL_2 =
	     { accumulatorqq_1[127], accumulatorqq_1[127:0] } ;
  assign MUX_accumulatorqq_1$write_1__VAL_3 = { accumulator_1, q_1, q1_1 } ;
  assign MUX_accumulatorqq_2$write_1__VAL_1 =
	     { 1'd0, accumulatorqq_2[128:1] } ;
  assign MUX_accumulatorqq_2$write_1__VAL_2 =
	     { accumulatorqq_2[127], accumulatorqq_2[127:0] } ;
  assign MUX_accumulatorqq_2$write_1__VAL_3 = { accumulator_2, q_2, q1_2 } ;
  assign MUX_accumulatorqq_3$write_1__VAL_1 =
	     { 1'd0, accumulatorqq_3[128:1] } ;
  assign MUX_accumulatorqq_3$write_1__VAL_2 =
	     { accumulatorqq_3[127], accumulatorqq_3[127:0] } ;
  assign MUX_accumulatorqq_3$write_1__VAL_3 = { accumulator_3, q_3, q1_3 } ;
  assign MUX_counter$write_1__VAL_1 = counter + 8'd1 ;
  assign MUX_q$write_1__VAL_2 = { 1'd0, q[63:1] } ;
  assign MUX_q$write_1__VAL_3 = { accumulatorqq[64], q[62:0] } ;
  assign MUX_q_1$write_1__VAL_2 = { 1'd0, q_1[63:1] } ;
  assign MUX_q_1$write_1__VAL_3 = { accumulatorqq_1[64], q_1[62:0] } ;
  assign MUX_q_2$write_1__VAL_2 = { 1'd0, q_2[63:1] } ;
  assign MUX_q_2$write_1__VAL_3 = { accumulatorqq_2[64], q_2[62:0] } ;
  assign MUX_q_3$write_1__VAL_2 = { 1'd0, q_3[63:1] } ;
  assign MUX_q_3$write_1__VAL_3 = { accumulatorqq_3[64], q_3[62:0] } ;
  assign MUX_state$write_1__VAL_1 = (counter == 8'd16) ? 4'd0 : 4'd1 ;

  // register accumulator
  always@(MUX_accumulator$write_1__SEL_1 or
	  MUX_accumulator$write_1__SEL_2 or
	  MUX_accumulator$write_1__VAL_2 or
	  state or
	  MUX_accumulator$write_1__VAL_3 or MUX_accumulator$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: accumulator$D_IN = 64'd0;
      MUX_accumulator$write_1__SEL_2:
	  accumulator$D_IN = MUX_accumulator$write_1__VAL_2;
      state == 4'd3: accumulator$D_IN = MUX_accumulator$write_1__VAL_3;
      state == 4'd4: accumulator$D_IN = MUX_accumulator$write_1__VAL_4;
      default: accumulator$D_IN =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulator$EN =
	     state == 4'd5 && counter == 8'd16 ||
	     state == 4'd6 && (qq == 2'b01 || qq == 2'b10) ||
	     state == 4'd3 ||
	     state == 4'd4 ;

  // register accumulator_1
  always@(MUX_accumulator$write_1__SEL_1 or
	  accumulator or
	  MUX_accumulator_1$write_1__SEL_2 or
	  MUX_accumulator_1$write_1__VAL_2 or
	  state or
	  MUX_accumulator_1$write_1__VAL_3 or
	  MUX_accumulator_1$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: accumulator_1$D_IN = accumulator;
      MUX_accumulator_1$write_1__SEL_2:
	  accumulator_1$D_IN = MUX_accumulator_1$write_1__VAL_2;
      state == 4'd3: accumulator_1$D_IN = MUX_accumulator_1$write_1__VAL_3;
      state == 4'd4: accumulator_1$D_IN = MUX_accumulator_1$write_1__VAL_4;
      default: accumulator_1$D_IN =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulator_1$EN =
	     state == 4'd5 && counter == 8'd16 ||
	     state == 4'd6 && (qq_1 == 2'b01 || qq_1 == 2'b10) ||
	     state == 4'd3 ||
	     state == 4'd4 ;

  // register accumulator_2
  always@(MUX_accumulator$write_1__SEL_1 or
	  accumulator_1 or
	  MUX_accumulator_2$write_1__SEL_2 or
	  MUX_accumulator_2$write_1__VAL_2 or
	  state or
	  MUX_accumulator_2$write_1__VAL_3 or
	  MUX_accumulator_2$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: accumulator_2$D_IN = accumulator_1;
      MUX_accumulator_2$write_1__SEL_2:
	  accumulator_2$D_IN = MUX_accumulator_2$write_1__VAL_2;
      state == 4'd3: accumulator_2$D_IN = MUX_accumulator_2$write_1__VAL_3;
      state == 4'd4: accumulator_2$D_IN = MUX_accumulator_2$write_1__VAL_4;
      default: accumulator_2$D_IN =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulator_2$EN =
	     state == 4'd5 && counter == 8'd16 ||
	     state == 4'd6 && (qq_2 == 2'b01 || qq_2 == 2'b10) ||
	     state == 4'd3 ||
	     state == 4'd4 ;

  // register accumulator_3
  always@(MUX_accumulator$write_1__SEL_1 or
	  accumulator_2 or
	  MUX_accumulator_3$write_1__SEL_2 or
	  MUX_accumulator_3$write_1__VAL_2 or
	  state or
	  MUX_accumulator_3$write_1__VAL_3 or
	  MUX_accumulator_3$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: accumulator_3$D_IN = accumulator_2;
      MUX_accumulator_3$write_1__SEL_2:
	  accumulator_3$D_IN = MUX_accumulator_3$write_1__VAL_2;
      state == 4'd3: accumulator_3$D_IN = MUX_accumulator_3$write_1__VAL_3;
      state == 4'd4: accumulator_3$D_IN = MUX_accumulator_3$write_1__VAL_4;
      default: accumulator_3$D_IN =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulator_3$EN =
	     state == 4'd5 && counter == 8'd16 ||
	     state == 4'd6 && (qq_3 == 2'b01 || qq_3 == 2'b10) ||
	     state == 4'd3 ||
	     state == 4'd4 ;

  // register accumulatorqq
  always@(state or
	  MUX_accumulatorqq$write_1__VAL_1 or
	  MUX_accumulatorqq$write_1__VAL_2 or
	  MUX_accumulatorqq$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd3: accumulatorqq$D_IN = MUX_accumulatorqq$write_1__VAL_1;
      state == 4'd4: accumulatorqq$D_IN = MUX_accumulatorqq$write_1__VAL_2;
      state == 4'd2: accumulatorqq$D_IN = MUX_accumulatorqq$write_1__VAL_3;
      default: accumulatorqq$D_IN =
		   129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulatorqq$EN = state == 4'd3 || state == 4'd4 || state == 4'd2 ;

  // register accumulatorqq_1
  always@(state or
	  MUX_accumulatorqq_1$write_1__VAL_1 or
	  MUX_accumulatorqq_1$write_1__VAL_2 or
	  MUX_accumulatorqq_1$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd3:
	  accumulatorqq_1$D_IN = MUX_accumulatorqq_1$write_1__VAL_1;
      state == 4'd4:
	  accumulatorqq_1$D_IN = MUX_accumulatorqq_1$write_1__VAL_2;
      state == 4'd2:
	  accumulatorqq_1$D_IN = MUX_accumulatorqq_1$write_1__VAL_3;
      default: accumulatorqq_1$D_IN =
		   129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulatorqq_1$EN =
	     state == 4'd3 || state == 4'd4 || state == 4'd2 ;

  // register accumulatorqq_2
  always@(state or
	  MUX_accumulatorqq_2$write_1__VAL_1 or
	  MUX_accumulatorqq_2$write_1__VAL_2 or
	  MUX_accumulatorqq_2$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd3:
	  accumulatorqq_2$D_IN = MUX_accumulatorqq_2$write_1__VAL_1;
      state == 4'd4:
	  accumulatorqq_2$D_IN = MUX_accumulatorqq_2$write_1__VAL_2;
      state == 4'd2:
	  accumulatorqq_2$D_IN = MUX_accumulatorqq_2$write_1__VAL_3;
      default: accumulatorqq_2$D_IN =
		   129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulatorqq_2$EN =
	     state == 4'd3 || state == 4'd4 || state == 4'd2 ;

  // register accumulatorqq_3
  always@(state or
	  MUX_accumulatorqq_3$write_1__VAL_1 or
	  MUX_accumulatorqq_3$write_1__VAL_2 or
	  MUX_accumulatorqq_3$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd3:
	  accumulatorqq_3$D_IN = MUX_accumulatorqq_3$write_1__VAL_1;
      state == 4'd4:
	  accumulatorqq_3$D_IN = MUX_accumulatorqq_3$write_1__VAL_2;
      state == 4'd2:
	  accumulatorqq_3$D_IN = MUX_accumulatorqq_3$write_1__VAL_3;
      default: accumulatorqq_3$D_IN =
		   129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign accumulatorqq_3$EN =
	     state == 4'd3 || state == 4'd4 || state == 4'd2 ;

  // register counter
  assign counter$D_IN = (state == 4'd3) ? MUX_counter$write_1__VAL_1 : 8'd0 ;
  assign counter$EN = state == 4'd3 || EN_put_val ;

  // register counter_1
  assign counter_1$D_IN = 8'h0 ;
  assign counter_1$EN = 1'b0 ;

  // register counter_2
  assign counter_2$D_IN = 8'h0 ;
  assign counter_2$EN = 1'b0 ;

  // register counter_3
  assign counter_3$D_IN = 8'h0 ;
  assign counter_3$EN = 1'b0 ;

  // register delay
  assign delay$D_IN = delay + 2'd1 ;
  assign delay$EN = MUX_accumulator$write_1__SEL_1 ;

  // register m
  assign m$D_IN = put_val_data ;
  assign m$EN = EN_put_val ;

  // register m_1
  assign m_1$D_IN = m ;
  assign m_1$EN = MUX_accumulator$write_1__SEL_1 ;

  // register m_2
  assign m_2$D_IN = m_1 ;
  assign m_2$EN = MUX_accumulator$write_1__SEL_1 ;

  // register m_3
  assign m_3$D_IN = m_2 ;
  assign m_3$EN = MUX_accumulator$write_1__SEL_1 ;

  // register q
  always@(EN_put_val or
	  put_val_q_ or state or MUX_q$write_1__VAL_2 or MUX_q$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      EN_put_val: q$D_IN = put_val_q_;
      state == 4'd3: q$D_IN = MUX_q$write_1__VAL_2;
      state == 4'd4: q$D_IN = MUX_q$write_1__VAL_3;
      default: q$D_IN = 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign q$EN = EN_put_val || state == 4'd3 || state == 4'd4 ;

  // register q1
  assign q1$D_IN = !MUX_accumulator$write_1__SEL_1 && q[0] ;
  assign q1$EN = state == 4'd5 && counter == 8'd16 || state == 4'd3 ;

  // register q1_1
  assign q1_1$D_IN = MUX_accumulator$write_1__SEL_1 ? q1 : q_1[0] ;
  assign q1_1$EN = state == 4'd5 && counter == 8'd16 || state == 4'd3 ;

  // register q1_2
  assign q1_2$D_IN = MUX_accumulator$write_1__SEL_1 ? q1_1 : q_2[0] ;
  assign q1_2$EN = state == 4'd5 && counter == 8'd16 || state == 4'd3 ;

  // register q1_3
  assign q1_3$D_IN = MUX_accumulator$write_1__SEL_1 ? q1_2 : q_3[0] ;
  assign q1_3$EN = state == 4'd5 && counter == 8'd16 || state == 4'd3 ;

  // register q_1
  always@(MUX_accumulator$write_1__SEL_1 or
	  q or state or MUX_q_1$write_1__VAL_2 or MUX_q_1$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: q_1$D_IN = q;
      state == 4'd3: q_1$D_IN = MUX_q_1$write_1__VAL_2;
      state == 4'd4: q_1$D_IN = MUX_q_1$write_1__VAL_3;
      default: q_1$D_IN = 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign q_1$EN =
	     state == 4'd5 && counter == 8'd16 || state == 4'd3 ||
	     state == 4'd4 ;

  // register q_2
  always@(MUX_accumulator$write_1__SEL_1 or
	  q_1 or state or MUX_q_2$write_1__VAL_2 or MUX_q_2$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: q_2$D_IN = q_1;
      state == 4'd3: q_2$D_IN = MUX_q_2$write_1__VAL_2;
      state == 4'd4: q_2$D_IN = MUX_q_2$write_1__VAL_3;
      default: q_2$D_IN = 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign q_2$EN =
	     state == 4'd5 && counter == 8'd16 || state == 4'd3 ||
	     state == 4'd4 ;

  // register q_3
  always@(MUX_accumulator$write_1__SEL_1 or
	  q_2 or state or MUX_q_3$write_1__VAL_2 or MUX_q_3$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_accumulator$write_1__SEL_1: q_3$D_IN = q_2;
      state == 4'd3: q_3$D_IN = MUX_q_3$write_1__VAL_2;
      state == 4'd4: q_3$D_IN = MUX_q_3$write_1__VAL_3;
      default: q_3$D_IN = 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign q_3$EN =
	     state == 4'd5 && counter == 8'd16 || state == 4'd3 ||
	     state == 4'd4 ;

  // register qq
  assign qq$D_IN = { q[0], q1 } ;
  assign qq$EN = state == 4'd1 ;

  // register qq_1
  assign qq_1$D_IN = { q_1[0], q1_1 } ;
  assign qq_1$EN = state == 4'd1 ;

  // register qq_2
  assign qq_2$D_IN = { q_2[0], q1_2 } ;
  assign qq_2$EN = state == 4'd1 ;

  // register qq_3
  assign qq_3$D_IN = { q_3[0], q1_3 } ;
  assign qq_3$EN = state == 4'd1 ;

  // register state
  always@(state or MUX_state$write_1__VAL_1 or EN_put_val)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd5: state$D_IN = MUX_state$write_1__VAL_1;
      EN_put_val: state$D_IN = 4'd1;
      state == 4'd6: state$D_IN = 4'd2;
      state == 4'd2: state$D_IN = 4'd3;
      state == 4'd3: state$D_IN = 4'd4;
      state == 4'd4: state$D_IN = 4'd5;
      state == 4'd1: state$D_IN = 4'd6;
      default: state$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     state == 4'd5 || EN_put_val || state == 4'd6 || state == 4'd2 ||
	     state == 4'd3 ||
	     state == 4'd4 ||
	     state == 4'd1 ;

  // remaining internal signals
  assign x__h1298 = accumulator + m ;
  assign x__h1360 = accumulator - m ;
  assign x__h1429 = accumulator_1 + m_1 ;
  assign x__h1476 = accumulator_1 - m_1 ;
  assign x__h1547 = accumulator_2 + m_2 ;
  assign x__h1594 = accumulator_2 - m_2 ;
  assign x__h1665 = accumulator_3 + m_3 ;
  assign x__h1712 = accumulator_3 - m_3 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        accumulator <= `BSV_ASSIGNMENT_DELAY 64'd0;
	accumulator_1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	accumulator_2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	accumulator_3 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	accumulatorqq <= `BSV_ASSIGNMENT_DELAY 129'd0;
	accumulatorqq_1 <= `BSV_ASSIGNMENT_DELAY 129'd0;
	accumulatorqq_2 <= `BSV_ASSIGNMENT_DELAY 129'd0;
	accumulatorqq_3 <= `BSV_ASSIGNMENT_DELAY 129'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 8'd64;
	counter_1 <= `BSV_ASSIGNMENT_DELAY 8'd64;
	counter_2 <= `BSV_ASSIGNMENT_DELAY 8'd64;
	counter_3 <= `BSV_ASSIGNMENT_DELAY 8'd64;
	delay <= `BSV_ASSIGNMENT_DELAY 2'd0;
	m <= `BSV_ASSIGNMENT_DELAY 64'd0;
	m_1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	m_2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	m_3 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	q <= `BSV_ASSIGNMENT_DELAY 64'd0;
	q1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	q1_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	q1_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	q1_3 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	q_1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	q_2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	q_3 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	qq <= `BSV_ASSIGNMENT_DELAY 2'd0;
	qq_1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	qq_2 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	qq_3 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	state <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (accumulator$EN)
	  accumulator <= `BSV_ASSIGNMENT_DELAY accumulator$D_IN;
	if (accumulator_1$EN)
	  accumulator_1 <= `BSV_ASSIGNMENT_DELAY accumulator_1$D_IN;
	if (accumulator_2$EN)
	  accumulator_2 <= `BSV_ASSIGNMENT_DELAY accumulator_2$D_IN;
	if (accumulator_3$EN)
	  accumulator_3 <= `BSV_ASSIGNMENT_DELAY accumulator_3$D_IN;
	if (accumulatorqq$EN)
	  accumulatorqq <= `BSV_ASSIGNMENT_DELAY accumulatorqq$D_IN;
	if (accumulatorqq_1$EN)
	  accumulatorqq_1 <= `BSV_ASSIGNMENT_DELAY accumulatorqq_1$D_IN;
	if (accumulatorqq_2$EN)
	  accumulatorqq_2 <= `BSV_ASSIGNMENT_DELAY accumulatorqq_2$D_IN;
	if (accumulatorqq_3$EN)
	  accumulatorqq_3 <= `BSV_ASSIGNMENT_DELAY accumulatorqq_3$D_IN;
	if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (counter_1$EN) counter_1 <= `BSV_ASSIGNMENT_DELAY counter_1$D_IN;
	if (counter_2$EN) counter_2 <= `BSV_ASSIGNMENT_DELAY counter_2$D_IN;
	if (counter_3$EN) counter_3 <= `BSV_ASSIGNMENT_DELAY counter_3$D_IN;
	if (delay$EN) delay <= `BSV_ASSIGNMENT_DELAY delay$D_IN;
	if (m$EN) m <= `BSV_ASSIGNMENT_DELAY m$D_IN;
	if (m_1$EN) m_1 <= `BSV_ASSIGNMENT_DELAY m_1$D_IN;
	if (m_2$EN) m_2 <= `BSV_ASSIGNMENT_DELAY m_2$D_IN;
	if (m_3$EN) m_3 <= `BSV_ASSIGNMENT_DELAY m_3$D_IN;
	if (q$EN) q <= `BSV_ASSIGNMENT_DELAY q$D_IN;
	if (q1$EN) q1 <= `BSV_ASSIGNMENT_DELAY q1$D_IN;
	if (q1_1$EN) q1_1 <= `BSV_ASSIGNMENT_DELAY q1_1$D_IN;
	if (q1_2$EN) q1_2 <= `BSV_ASSIGNMENT_DELAY q1_2$D_IN;
	if (q1_3$EN) q1_3 <= `BSV_ASSIGNMENT_DELAY q1_3$D_IN;
	if (q_1$EN) q_1 <= `BSV_ASSIGNMENT_DELAY q_1$D_IN;
	if (q_2$EN) q_2 <= `BSV_ASSIGNMENT_DELAY q_2$D_IN;
	if (q_3$EN) q_3 <= `BSV_ASSIGNMENT_DELAY q_3$D_IN;
	if (qq$EN) qq <= `BSV_ASSIGNMENT_DELAY qq$D_IN;
	if (qq_1$EN) qq_1 <= `BSV_ASSIGNMENT_DELAY qq_1$D_IN;
	if (qq_2$EN) qq_2 <= `BSV_ASSIGNMENT_DELAY qq_2$D_IN;
	if (qq_3$EN) qq_3 <= `BSV_ASSIGNMENT_DELAY qq_3$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    accumulator = 64'hAAAAAAAAAAAAAAAA;
    accumulator_1 = 64'hAAAAAAAAAAAAAAAA;
    accumulator_2 = 64'hAAAAAAAAAAAAAAAA;
    accumulator_3 = 64'hAAAAAAAAAAAAAAAA;
    accumulatorqq = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    accumulatorqq_1 = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    accumulatorqq_2 = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    accumulatorqq_3 = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    counter = 8'hAA;
    counter_1 = 8'hAA;
    counter_2 = 8'hAA;
    counter_3 = 8'hAA;
    delay = 2'h2;
    m = 64'hAAAAAAAAAAAAAAAA;
    m_1 = 64'hAAAAAAAAAAAAAAAA;
    m_2 = 64'hAAAAAAAAAAAAAAAA;
    m_3 = 64'hAAAAAAAAAAAAAAAA;
    q = 64'hAAAAAAAAAAAAAAAA;
    q1 = 1'h0;
    q1_1 = 1'h0;
    q1_2 = 1'h0;
    q1_3 = 1'h0;
    q_1 = 64'hAAAAAAAAAAAAAAAA;
    q_2 = 64'hAAAAAAAAAAAAAAAA;
    q_3 = 64'hAAAAAAAAAAAAAAAA;
    qq = 2'h2;
    qq_1 = 2'h2;
    qq_2 = 2'h2;
    qq_3 = 2'h2;
    state = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMul

